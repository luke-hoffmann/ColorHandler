var colorhandler=(function(exports){'use strict';var l=class{static getIndexOfArrayMax(e){if(!Array.isArray(e))throw Error("arrayOfNumbers is not an array");if(e.length==0)throw Error("arrayOfNumbers contains no elements");let r=0,t=e[0];for(let n=0;n<e.length;n++){let o=e[n];o>t&&(t=o,r=n);}return r}static isMixedUpArraysEqual(e,r){if(e.length!==r.length)return  false;e=[...e],r=[...r];for(let t=e.length-1;t>=0;t--)for(let n=r.length-1;n>=0;n--)e[t]===r[n]&&(e.splice(t,1),r.splice(n,1));return e.length==0&&r.length==0}static isThereValueGreaterThanN(e,r){for(let t of e)if(t>r)return  true;return  false}static combineArrays(e){let r=[];for(let t of e)for(let n of t)r.push(n);return r}static arrayOfIndices(e){let r=[];for(let t=0;t<e;t++)r.push(t);return r}static addToMap(e,r,t){e.has(r)||e.set(r,[]);e.get(r).push(t);return e}static incrementMap(e,r){if(!e.has(r))throw new Error("Supplied map is bad");e.set(r,e.get(r)+1);}static isInArray(e,r){for(let t=0;t<e.length;t++)if(e[t]===r)return  true;return  false}static getCounterClockwiseMove(e,r){if(!e.has(r))throw Error("Key not found");let t=[...e.get(r)];if(t.length==1)return r=t[0],r;for(let n=t.length-1;n>=0;n--)this.doesMoveExistElsewhere(e,r,t[n])&&t.splice(n,1);return t[0]}static doesMoveExistElsewhere(e,r,t){if(e.has(r)==false)throw new Error("Could not find node");return this.isInArray(e.get(t),r)}static doesKeyHaveSpecificValue(e,r,t){if(!e.has(r))throw Error("Key not found in hash graph");let n=e.get(r);for(let o=0;o<n.length;o++)if(n[o]===t)return  true;return  false}static findNodeThatHasSpecificNodeAsConnection(e,r,t,n){if(!e.has(r))throw Error("Key not found in hash graph");let o=e.get(r);for(let i=0;i<o.length;i++)if(o[i]!==n&&this.doesKeyHaveSpecificValue(e,o[i],t))return o[i];return  -1}static runSearchMovementAroundCenter(e,r,t,n,o){let i=100,a=1,s=t,u=n,h=r;for(;s!=h;){if(a++,a>i||s==-1)return  false;let d=s;s=this.findNodeThatHasSpecificNodeAsConnection(e,s,u,o),o=d;}return  true}static isNodeSurroundedByNodes(e,r){if(!e.has(r))throw Error("Key not found in hash graph");let t=e.get(r),i=[];for(let a=0;a<t.length;a++){let s=t[a],u=s,h=this.findNodeThatHasSpecificNodeAsConnection(e,s,r,u),d=this.runSearchMovementAroundCenter(e,s,h,r,u);i.push(d);}return this.isInArray(i,true)}static getOutsideNode(e){for(let r of e.keys())if(!this.isNodeSurroundedByNodes(e,r))return r;return  -1}static randomIntBetween(e,r){let t=Math.round(Math.random()*(r-e));return e+t}static multiplyArray(e,r){let t=[];for(let n of e)t.push(n*r);return t}static divideArray(e,r){if(r==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let t=[];for(let n of e)t.push(n/r);return t}static elementWiseMultiplication(e,r){if(e.length!=r.length)throw new Error("Array lengths are different!");let t=[];for(let n=0;n<e.length;n++)t.push(e[n]*r[n]);return t}static randomP5Color(){return "rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(e,r){r==null&&(r=15);let t=1;new Map(e);let o=this.getOutsideNode(e),i=this.getCounterClockwiseMove(e,o),a=[];for(;t<r&&i!=o;){t++;let s=this.getCounterClockwiseMove(e,i);a.push(i),i=s;}return a.push(i),a}static addElementsToArray(e,r){for(let t of r)e.push(t);}static removeIndicesFromArray(e,r){e=[...e];let t;for(let n=r.length-1;n>=0;n--)t=r[n],e.splice(t,1);return e}static clampNumber(e,r,t){return e=e>t?t:e,e=e<r?r:e,e}};l.noDuplicates=e=>[...new Set(e)];var m=class e{#r;#e;#t;#n;static{this.BLACK=new e(0,0,0);}static{this.WHITE=new e(255,255,255);}constructor(r,t,n){if(!Number.isFinite(r))throw Error("red must be a finite number");if(!Number.isFinite(t))throw Error("green must be a finite number");if(!Number.isFinite(n))throw Error("blue must be a finite number");this.#r=Math.min(Math.max(0,r),255),this.#e=Math.min(Math.max(0,t),255),this.#t=Math.min(Math.max(0,n),255),this.#n=[r,t,n];}static random(){return new e(l.randomIntBetween(0,255),l.randomIntBetween(0,255),l.randomIntBetween(0,255))}get red(){return this.#r}get green(){return this.#e}get blue(){return this.#t}setRed(r){this.#r=r;}setGreen(r){this.#e=r;}setBlue(r){this.#t=r;}multiplyByNumber(r){return new e(this.#r*r,this.#e*r,this.#t*r)}static randomColorsBetween(r,t,n){let o=[];for(let i=0;i<r;i++)o.push(this.randomColorBetween(t,n));return o}static randomColorBetween(r,t){return new e(l.randomIntBetween(r.red,t.red),l.randomIntBetween(r.green,t.green),l.randomIntBetween(r.blue,t.blue))}static randomColorAtWithGeneralRadius(r,t){return this.randomColorAtWithRadius(r,t,t,t)}static randomColorAtWithRadius(r,t,n,o){let i=new e(r.red-t,r.green-n,r.blue-o),a=new e(r.red+t,r.green+n,r.blue+o);return this.randomColorBetween(i,a)}static randomColorPercentTimeWithRadius(r,t,n,o){return (o>1||o<0)&&(o=.5),Math.random()<o?this.randomColorAtWithGeneralRadius(r,n):this.randomColorAtWithGeneralRadius(t,n)}addNumber(r){if(!Number.isFinite(r))throw Error("number is not finite");return new e(this.#r+r,this.#e+r,this.#t+r)}addColor(r){return new e(this.#r+r.red,this.#e+r.green,this.#t+r.blue)}addInto(r){this.#r+=r.red,this.#e+=r.green,this.#t+=r.blue;}copy(){return new e(this.#r,this.#e,this.#t)}clampColor(){let r=this.#r>255?255:this.#r;r=this.#r<0?0:this.#r;let t=this.#e>255?255:this.#e;t=this.#e<0?0:this.#e;let n=this.#t>255?255:this.#t;return n=this.#t<0?0:this.#t,new e(r,t,n)}static sumAndClamp(r){let t=new e(0,0,0);for(let o of r)t=o.addColor(t);return new e(l.clampNumber(t.red,0,255),l.clampNumber(t.green,0,255),l.clampNumber(t.blue,0,255))}elementWiseMultiplication(r){return new e(r.red*this.#r,r.green*this.#e,r.blue*this.#t)}};exports.ColorHandler=m;return exports;})({});