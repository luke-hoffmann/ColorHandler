var colorhandler=(function(exports){'use strict';var l=class{static getIndexOfArrayMax(e){if(!Array.isArray(e))throw Error("arrayOfNumbers is not an array");if(e.length==0)throw Error("arrayOfNumbers contains no elements");let r=0,t=e[0];for(let n=0;n<e.length;n++){let i=e[n];i>t&&(t=i,r=n);}return r}static isMixedUpArraysEqual(e,r){if(e.length!==r.length)return  false;e=[...e],r=[...r];for(let t=e.length-1;t>=0;t--)for(let n=r.length-1;n>=0;n--)e[t]===r[n]&&(e.splice(t,1),r.splice(n,1));return e.length==0&&r.length==0}static isThereValueGreaterThanN(e,r){for(let t of e)if(t>r)return  true;return  false}static combineArrays(e){let r=[];for(let t of e)for(let n of t)r.push(n);return r}static arrayOfIndices(e){let r=[];for(let t=0;t<e;t++)r.push(t);return r}static addToMap(e,r,t){e.has(r)||e.set(r,[]);e.get(r).push(t);return e}static incrementMap(e,r){if(!e.has(r))throw new Error("Supplied map is bad");e.set(r,e.get(r)+1);}static isInArray(e,r){for(let t=0;t<e.length;t++)if(e[t]===r)return  true;return  false}static getCounterClockwiseMove(e,r){if(!e.has(r))throw Error("Key not found");let t=[...e.get(r)];if(t.length==1)return r=t[0],r;for(let n=t.length-1;n>=0;n--)this.doesMoveExistElsewhere(e,r,t[n])&&t.splice(n,1);return t[0]}static doesMoveExistElsewhere(e,r,t){if(e.has(r)==false)throw new Error("Could not find node");return this.isInArray(e.get(t),r)}static doesKeyHaveSpecificValue(e,r,t){if(!e.has(r))throw Error("Key not found in hash graph");let n=e.get(r);for(let i=0;i<n.length;i++)if(n[i]===t)return  true;return  false}static findNodeThatHasSpecificNodeAsConnection(e,r,t,n){if(!e.has(r))throw Error("Key not found in hash graph");let i=e.get(r);for(let o=0;o<i.length;o++)if(i[o]!==n&&this.doesKeyHaveSpecificValue(e,i[o],t))return i[o];return  -1}static runSearchMovementAroundCenter(e,r,t,n,i){let o=100,s=1,a=t,u=n,h=r;for(;a!=h;){if(s++,s>o||a==-1)return  false;let d=a;a=this.findNodeThatHasSpecificNodeAsConnection(e,a,u,i),i=d;}return  true}static isNodeSurroundedByNodes(e,r){if(!e.has(r))throw Error("Key not found in hash graph");let t=e.get(r),o=[];for(let s=0;s<t.length;s++){let a=t[s],u=a,h=this.findNodeThatHasSpecificNodeAsConnection(e,a,r,u),d=this.runSearchMovementAroundCenter(e,a,h,r,u);o.push(d);}return this.isInArray(o,true)}static getOutsideNode(e){for(let r of e.keys())if(!this.isNodeSurroundedByNodes(e,r))return r;return  -1}static randomIntBetween(e,r){let t=Math.round(Math.random()*(r-e));return e+t}static multiplyArray(e,r){let t=[];for(let n of e)t.push(n*r);return t}static divideArray(e,r){if(r==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let t=[];for(let n of e)t.push(n/r);return t}static elementWiseMultiplication(e,r){if(e.length!=r.length)throw new Error("Array lengths are different!");let t=[];for(let n=0;n<e.length;n++)t.push(e[n]*r[n]);return t}static randomP5Color(){return "rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(e,r){r==null&&(r=15);let t=1;new Map(e);let i=this.getOutsideNode(e),o=this.getCounterClockwiseMove(e,i),s=[];for(;t<r&&o!=i;){t++;let a=this.getCounterClockwiseMove(e,o);s.push(o),o=a;}return s.push(o),s}static addElementsToArray(e,r){for(let t of r)e.push(t);}static removeIndicesFromArray(e,r){e=[...e];let t;for(let n=r.length-1;n>=0;n--)t=r[n],e.splice(t,1);return e}static clampNumber(e,r,t){return e=e>t?t:e,e=e<r?r:e,e}};l.noDuplicates=e=>[...new Set(e)];var f=class e{#r;#e;#t;#n;constructor(r,t,n){if(!Number.isFinite(r))throw Error("red must be a finite number");if(!Number.isFinite(t))throw Error("green must be a finite number");if(!Number.isFinite(n))throw Error("blue must be a finite number");this.#r=Math.min(Math.max(0,r),255),this.#e=Math.min(Math.max(0,t),255),this.#t=Math.min(Math.max(0,n),255),this.#n=[r,t,n];}static random(){return new e(l.randomIntBetween(0,255),l.randomIntBetween(0,255),l.randomIntBetween(0,255))}get red(){return this.#r}get green(){return this.#e}get blue(){return this.#t}setRed(r){this.#r=r;}setGreen(r){this.#e=r;}setBlue(r){this.#t=r;}multiplyByNumber(r){return new e(this.#r*r,this.#e*r,this.#t*r)}static randomColorBetween(r,t){return new e(l.randomIntBetween(r.red,t.red),l.randomIntBetween(r.green,t.green),l.randomIntBetween(r.blue,t.blue))}static randomColorAtWithGeneralRadius(r,t){return this.randomColorAtWithRadius(r,t,t,t)}static randomColorAtWithRadius(r,t,n,i){let o=new e(r.red-t,r.green-n,r.blue-i),s=new e(r.red+t,r.green+n,r.blue+i);return this.randomColorBetween(o,s)}addNumber(r){if(!Number.isFinite(r))throw Error("number is not finite");return new e(this.#r+r,this.#e+r,this.#t+r)}addColor(r){return new e(this.#r+r.red,this.#e+r.green,this.#t+r.blue)}copy(){return new e(this.#r,this.#e,this.#t)}clampColor(){let r=this.#r>255?255:this.#r;r=this.#r<0?0:this.#r;let t=this.#e>255?255:this.#e;t=this.#e<0?0:this.#e;let n=this.#t>255?255:this.#t;return n=this.#t<0?0:this.#t,new e(r,t,n)}static sumAndClamp(r){let t=new e(0,0,0);for(let i of r)t=i.addColor(t);return new e(l.clampNumber(t.red,0,255),l.clampNumber(t.green,0,255),l.clampNumber(t.blue,0,255))}elementWiseMultiplication(r){return new e(r.red*this.#r,r.green*this.#e,r.blue*this.#t)}};exports.ColorHandler=f;return exports;})({});